#!/usr/bin/env python

'''
I don't feel like makeing a rekey (password change) dialog at the moment.
To change the password, open python terminal
>>> import SecretKeeper
>>> SecretKeeper.rekey('old_key', 'new_key')
'''

#default key (password) = 'nicol'

geometry = "400x500+300+300" #default  

LATEST = 1 # simplecrypt version (0-2). version 2 is better but I prefer speed over security. Change anytime.

import Tkinter as tk
import ttk
from ScrolledText import ScrolledText
from sys import argv

###### stolen from simplecrypt; see https://pypi.python.org/pypi/simple-crypt #####

from Crypto.Cipher import AES
from Crypto.Hash import SHA256, HMAC
from Crypto.Protocol.KDF import PBKDF2
from Crypto.Random.random import getrandbits
from Crypto.Util import Counter

# see: http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html

EXPANSION_COUNT = (10000, 10000, 100000) 
AES_KEY_LEN = 256
SALT_LEN = (128, 256, 256)
HASH = SHA256
PREFIX = b'sc'
HEADER = (PREFIX + b'\x00\x00', PREFIX + b'\x00\x01', PREFIX + b'\x00\x02')

# lengths here are in bits, but pcrypto uses block size in bytes
HALF_BLOCK = AES.block_size*8//2
for salt_len in SALT_LEN:
	assert HALF_BLOCK <= salt_len  # we use a subset of the salt as nonce

HEADER_LEN = 4

def encrypt(password, data):
	'''
	Encrypt some data.  Input can be bytes or a string (which will be encoded
	using UTF-8).

	@param password: The secret value used as the basis for a key.
	This should be as long as varied as possible.  Try to avoid common words.

	@param data: The data to be encrypted.

	@return: The encrypted data, as bytes.
	'''
	data = _str_to_bytes(data)
	_assert_encrypt_length(data)
	salt = bytes(_random_bytes(SALT_LEN[LATEST]//8))
	hmac_key, cipher_key = _expand_keys(password, salt, EXPANSION_COUNT[LATEST])
	counter = Counter.new(HALF_BLOCK, prefix=salt[:HALF_BLOCK//8])
	cipher = AES.new(cipher_key, AES.MODE_CTR, counter=counter)
	encrypted = cipher.encrypt(data)
	hmac = _hmac(hmac_key, HEADER[LATEST] + salt + encrypted)
	output = HEADER[LATEST] + salt + encrypted + hmac
	return output.encode('base64')


def decrypt(password, data):
	'''
	Decrypt some data.  Input must be bytes.

	@param password: The secret value used as the basis for a key.
	This should be as long as varied as possible.  Try to avoid common words.

	@param data: The data to be decrypted, typically as bytes.

	@return: The decrypted data, as bytes.  If the original message was a
	string you can re-create that using `result.decode('utf8')`.
	'''
	data = data.decode('base64')
	_assert_not_unicode(data)
	_assert_header_prefix(data)
	version = _assert_header_version(data)
	_assert_decrypt_length(data, version)
	raw = data[HEADER_LEN:]
	salt = raw[:SALT_LEN[version]//8]
	hmac_key, cipher_key = _expand_keys(password, salt, EXPANSION_COUNT[version])
	hmac = raw[-HASH.digest_size:]
	hmac2 = _hmac(hmac_key, data[:-HASH.digest_size])
	_assert_hmac(hmac_key, hmac, hmac2)
	counter = Counter.new(HALF_BLOCK, prefix=salt[:HALF_BLOCK//8])
	cipher = AES.new(cipher_key, AES.MODE_CTR, counter=counter)
	return cipher.decrypt(raw[SALT_LEN[version]//8:-HASH.digest_size])

class DecryptionException(Exception): pass
class EncryptionException(Exception): pass

def _assert_not_unicode(data):
	# warn confused users
	u_type = type(b''.decode('utf8'))
	if isinstance(data, u_type):
		raise DecryptionException('Data to decrypt must be b ytes; ' +
		'you cannot use a string because no string encoding will accept all possible characters.')

def _assert_encrypt_length(data):
	# for AES this is never going to fail
	if len(data) > 2**HALF_BLOCK:
		raise EncryptionException('Message too long.')

def _assert_decrypt_length(data, version):
	if len(data) < HEADER_LEN + SALT_LEN[version]//8 + HASH.digest_size:
		raise DecryptionException('Missing data.')
	
def _assert_header_prefix(data):
	if len(data) >= 2 and data[:2] != PREFIX:
		raise DecryptionException('Data passed to decrypt were not generated by simple-crypt (bad header).')

def _assert_header_version(data):
	if len(data) >= HEADER_LEN:
		try:
			return HEADER.index(data[:HEADER_LEN])
		except:
			raise DecryptionException(
				'The data appear to be encrypted with a more recent version of simple-crypt (bad header). ' +
				'Please update the library and try again.')
	else:
		raise DecryptionException('Missing header.')

def _assert_hmac(key, hmac, hmac2):
	# https://www.isecpartners.com/news-events/news/2011/february/double-hmac-verification.aspx
	if _hmac(key, hmac) != _hmac(key, hmac2):
		raise DecryptionException('Bad password or corrupt / modified data.')

def _pbkdf2(password, salt, n_bytes, count):
	# the form of the prf below is taken from the code for PBKDF2
	return PBKDF2(password, salt, dkLen=n_bytes,
				  count=count, prf=lambda p,s: HMAC.new(p,s,HASH).digest())

def _expand_keys(password, salt, expansion_count):
	if not salt: raise ValueError('Missing salt.')
	if not password: raise ValueError('Missing password.')
	key_len = AES_KEY_LEN // 8
	keys = _pbkdf2(_str_to_bytes(password), salt, 2*key_len, expansion_count)
	return keys[:key_len], keys[key_len:]

def _hide(ranbytes):
	# appelbaum recommends obscuring output from random number generators since it can reveal state.
	# we can do this explicitly with a hash, but this is what a PBKDF does anyway, so use one.
	# we don't care about the salt or work factor because there is a large space of values anyway.
	return bytearray(_pbkdf2(bytes(ranbytes), b'', len(ranbytes), 1))

def _random_bytes(n):
	return _hide(bytearray(getrandbits(8) for _ in range(n)))

def _hmac(key, data):
	return HMAC.new(key, data, HASH).digest()

def _str_to_bytes(data):
	u_type = type(b''.decode('utf8'))
	if isinstance(data, u_type):
		return data.encode('utf8')
	return data

##### end simplecrypt thievery #####

data_delim = ' '.join(('####dammed','data####\n'))
#default data
data='''
c2MAARjWKYtPGrLehP9WmvlptOwazIYIRPUCa8EGROV9DCo8pMdO6lFA6FC3mrjWOfLHCzGDzuZ0
4Ay5rnJasHXKo67rMCOGTKV8AKY6SONhkEKzwFHqkNHLZmPVi3H16uc=
'''

def save(new_data, key, new_geo=None):
	'''encrypt and save new data to this file
	new_data is an unencrypted string
	optionally provide a new geometry string'''
	global data #technically not needed in GUI mode since this is called only when quitting
	fn = __file__
	if fn.endswith('.pyc'):
		fn = fn[:-1] #an import would compile the file
	with open(fn, "r+") as f:
		contents = f.read().split(data_delim)
		if len(contents) != 3:
			raise TypeError, "File is not of the right type"
		data = encrypt(key, new_data)
		contents[1] = "geometry='%s'\n" % (new_geo or geometry)
		contents[1] += "data='''\n%s'''\n" % data
		#erase file and write new contents
		f.seek(0)
		f.truncate()
		f.write(data_delim.join(contents))
		
def rekey(old_key, new_key):
	'''change key for the global data'''
	secret = decrypt(old_key,data)
	save(secret, new_key)

class Window(ttk.Frame):
	def __init__(self, parent):
		self.tab_delim = "\n=====++++++=====\n"
		self.tabs = []
		self.dirty = False
		
		ttk.Frame.__init__(self, parent)
		self.parent = parent
		self.parent.title("Very Secret Things")
		self.style = ttk.Style()
		self.style.theme_use("default")
		self.pack(fill=tk.BOTH, expand=1)
		self.nb = ttk.Notebook(self)
		self.nb.pack(fill=tk.BOTH, expand=1)

		self.saveButton = ttk.Button(self, text="Close", command=self.save)
		self.saveButton.pack(side=tk.RIGHT, padx=5, pady=5)
		# I don't feel like making a rekey dialog atm
		#~ rekeyButton = ttk.Button(self, text="Re-Key", command=self.rekey)
		#~ rekeyButton.pack(side=tk.RIGHT, padx=5, pady=5)
		addButton = ttk.Button(self, text="Add Tab", command=self.add_tab)
		addButton.pack(side=tk.LEFT, padx=5, pady=5)
		delButton = ttk.Button(self, text="Delete Tab", command=self.rem_tab)
		delButton.pack(side=tk.LEFT, padx=5, pady=5)
		
		#add search tab
		f = ttk.Frame(self.nb)
		self.search = ttk.Entry(f)
		self.search.focus()
		self.search.pack(fill=tk.BOTH)
		self.search.bind("<KeyRelease>", self.search_key_press)
		self.search_result = ScrolledText(f, relief=tk.RAISED, wrap=tk.WORD, state=tk.DISABLED)
		self.search_result.pack(fill=tk.BOTH, expand=1)
		self.nb.add(f, text='search')
		
		#add other tabs
		for text in self.parent.secret.split(self.tab_delim):
			self.add_tab(text, dirty=False)
		self.nb.select(self.nb.tabs()[0]) #select search tab
	
	def search_key_press(self, key):
		'''if search key is found displays that line and all lines below
		it until an empty line is reached.'''
		search = self.search.get()
		found = []
		state = None
		for line in self.parent.secret.splitlines():
			if state is None:
				if search in line.lower():
					state = line
			else:
				if line.strip() == "":
					found.append(state)
					state = None
				else:
					state += "\n"+line
		if state is not None:
			found.append(state)
		self.search_result.config(state=tk.NORMAL)
		self.search_result.delete("0.0", tk.END)
		self.search_result.insert(tk.INSERT, "\n\n".join(found))
		self.search_result.config(state=tk.DISABLED)
	
	def save(self):
		if self.dirty: #file changed
			self.update(dirty=False)
			save(self.parent.secret, self.parent.key, self.parent.geometry())
		self.quit()
	
	def rem_tab(self):
		tabid = self.nb.select()
		if self.nb.index(tabid) > 0:
			#index minus 1 to account for search tab
			del self.tabs[self.nb.index(tabid)-1]
			self.nb.forget(tabid)
			self.update()
	
	def add_tab(self, text='new', dirty=True):
		f = ttk.Frame(self.nb)
		# see http://stackoverflow.com/questions/13832720/how-to-attach-a-scrollbar-to-a-text-widget
		t = ScrolledText(f, relief=tk.RAISED, wrap=tk.WORD)
		t.insert(tk.INSERT, text)
		t.pack(fill=tk.BOTH, expand=1)
		t.bind("<KeyRelease>", self.update)
		self.nb.add(f)
		self.tabs.append(t)
		self.nb.select(self.nb.tabs()[-1])
		self.update(dirty=dirty)
	
	def update(self, key=None, dirty=True):
		if dirty and not self.dirty:
			self.dirty = True
			self.saveButton.config(text="Save&Close")
		data = [tab.get('0.0', tk.END).rstrip() for tab in self.tabs]
		self.parent.secret = self.tab_delim.join(data)
		#update tab title
		tabid = self.nb.select()
		name = data[self.nb.index(tabid)-1].rstrip().split('\n',1)[0].strip()
		self.nb.tab(tabid, text=name or "empty")

class PasswordDialog(ttk.Frame):
	def __init__(self, parent):
		ttk.Frame.__init__(self, parent)
		self.parent = parent
		
		self.parent.title("Password")
		self.style = ttk.Style()
		self.style.theme_use("default")
		self.pack(fill=tk.BOTH, expand=1)
		
		self.label = ttk.Label(self, text="Enter your Password")
		self.label.pack()
		self.entry = ttk.Entry(self, show='*')
		self.entry.bind("<KeyRelease-Return>", self.store_pass)
		self.entry.pack()
		self.entry.focus()
		button = ttk.Button(self, text="Submit", command=self.store_pass)
		button.pack()

	def store_pass(self, event=None):
		self.parent.key = self.entry.get()
		if self.parent.key == "":
			self.quit() #user entered nothing; treat as user cancel 
		try:
			self.parent.secret = decrypt(self.parent.key,data)
			self.quit() #correct password
		except DecryptionException: 
			self.label.config(text = "Wrong Password", foreground="red")
			self.entry.delete(0, tk.END)


def main(password=None):
	root = tk.Tk()
	if password:
		root.secret = decrypt(password,data)
		root.key = password
	else:
		app = PasswordDialog(root)
		root.mainloop()
		app.destroy()

	root.geometry(geometry)
	root.minsize(280, 460)
	app = Window(root)
	root.mainloop()

####dammed data####

####dammed data####

if __name__ == '__main__':
	main(argv[1] if len(argv) > 1 else None)
